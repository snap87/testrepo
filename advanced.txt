git stash - тайник.
Т.е. мы сделали изменнеия, но не хотим чтобы их видел кто-то и они были в коммите. делаем git stash.
Он вернет нас к рабочему коммиту.
Если захоте вернуть в любой момент git stash apply -  и они в неприменненных изменениях GS появится.
git stash list - если их много. 
git stash apply номер индекса(0,1,2,3 или какой нужен).
чтобы добавить описание, то git shash -m "описание".
Пусть мы решили таки вернуть файл в проект.
git stash pop 0 - добавит файл в проект с индексом 0.
git stash drop 0  уберет из списка git stash list. УЧИТЫВАТЬ что при этом запись с индексом 1 станет нулевой, т.е. циферки не поедут.
git stash clear - удалит все записи.



МОжно ил вернуть ошибочно удаленный комит или ветку? можно
git reflog -харнит все измненеия в проекта. Хранит 2 недели!
Пусть мы удалил коммит (git reset --hard HEAD~1) и поняли что зря. В нем был файл 1.txt.
git reflog покажет все действия с репо за 14 дней.
Мы предпоследним действием видим удаление коммита. Выбираем id действия и говорим git reset --hard ID_действия по удалению.
Все. файл и коммит восстановлены. Указатель на него.
НА ветках тоже можно.
Т.е. сдеали ветку, добавили файл, удалили ветку.
Далее
Переключаемся на удаленный коммит. Указатель смещаеся на него. Мы снова можем создать ветку с тем же именем.

Если тебе нужно создать отдельную ветку с опредленным коммитом, тo:
1) в начале git checkout coomit_id
2) git switch -c имя ветки. ВСе. будет ветка с этим коммитом и теми что были ниже.
При fast forward type указатель смещается на последний коммит фичи ветки и все. Новоого коммита о слиянии не было!
Если мы хотими отменить слияние, тогда git reset --hard последний коммит мастер ветки

Пусть мы не хотим видеть кучу коммитов, что были в ветке фича. Тогда мы можем схлопнуть коммить командой
git merge --squash feature_branch
тогда у нас в мастере окажуется все измненеия предыдущих коммитов в рабочей области и нам нужно будет просто их закоммитить как отдельный коммит.

FF работает только тогда когда нет параллельных изменений. Т.е. только когда все коммиты есть только в фича ветке.

Git Rebase example

M : m1 m2
F : m1 m2 f1 f2

M: m1 m2 m3
F: m1 m2 m3 f1 f2

Т.е. при rebase м3 переносится в ветку фичи и от нее коммиты уже идут красиво как бы.
Git rebase создаст новые индентфикаторы коммитов. Использовать ТОЛЬКО В ЛОКАЛНЫХ РЕПО. ТАМ ГДЕ МНОГО РАБОТАЕТ ЛЮДЕЙ ТАК НЕЛЬЗЯ.


КОГДА ПРИМЕНЯТЬ:
Если ваша фича ветка основана на мастере, то нуможно применять это, дополняя свою фичу ветку, коммитами из мастера.
Ваши локлаьные id коммитов собьются, но от них никто не зависит, так что всем пофигу.
Для этого переходит в фичу ветку и говорит git rebase master.


cherry-pick - добавить конкретный коммит в ветку и сместить указатель на него.

Допустим есть мастер ветка с опечаткой в файле. Мы создали фича ветку от нее с той же опечаткой ессно.
Начали работать в фича ветке и сделалил 10 коммитов.
Затем мы вспоминаем, что в мастере есть опечатка. Мы в фича ветке ее исправляем и коммитим. Теперь как-то надо доставить сие счастье в мастер.
Слить нельзя, т.к. подтянется много изменений файлов(все коммиты). Нам нужен только 1 конкретный коммит с 1 конкретным изменением.
Это и делает git cherry-pick имя коммита.
Мы перемещаемся на мастер. Выбираем нужный коммит и делаем git cherry-pick имя коммита.
В этом случае получим изменнеия ТОЛЬКО данного коммита. Т.е. только там, где мы исправили опечатку.
В логе этот коммит будет с тем же именем, но другим идентификатором, т.к. это по сути новый коммит.


